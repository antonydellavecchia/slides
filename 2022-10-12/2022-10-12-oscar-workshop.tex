\documentclass[9pt]{beamer}
\beamertemplatenavigationsymbolsempty
\usetheme{Berlin}

\usepackage{etex, tikz, array, graphics, xspace, relsize, multirow}
\usepackage{ulem}

\input binhex

% For code inclusion
\usepackage{listings}
\lstset{ breaklines=true}
\lstset{escapeinside={<@}{@>}}
\usepackage{algorithm2e}
\usepackage{algorithmic}

% Commands
\newcommand\A{\mathcal{A}}
\newcommand\cc{\mathcal{C}}
\newcommand\codim{\mathrm{codim}}
\newcommand\CP{\mathbb{CP}}
\newcommand\C{\mathbb{C}}
\newcommand\D{\mathrm{D}}
\newcommand\hto{\hookrightarrow}
\newcommand\I{^{-1}}
\newcommand\oo{\mathcal{O}}
\renewcommand\phi{\varphi}
\newcommand\Pj{\mathbb{P}}
\newcommand\pow{\mathcal{P}}
\newcommand\RP{\mathbb{RP}}
\newcommand\rstr[2]{{\left.#1\right|_{#2}}}
\newcommand\R{\mathbb{R}}
\newcommand\V{\mathcal{V}}
\newcommand\H{\mathcal{H}}
\newcommand\set[1]{\{#1\}}
\newcommand\toi{\xrightarrow{\sim}} % category
\newcommand\Z{\mathbb{Z}}


% For drawing
%% Tikz drawing
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}
\usepackage{pgfplots}
\usepackage{tikz-3dplot}
\usepackage{tcolorbox}
\usetikzlibrary{matrix,fit,positioning,shapes.geometric,patterns,backgrounds}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{arrows,calc}
\tikzstyle{bigbox} = [draw=blue!50, thick, rounded corners, rectangle]
\tikzset{
>=stealth'
}
\tikzset{->-/.style={decoration={
  markings,
  mark=at position #1 with {\arrow{>}}},postaction={decorate}}}

%% Software names
\newcommand\topcom{\texttt{TOPCOM}\xspace}
\newcommand\mptopcom{\texttt{MPTOPCOM}\xspace}
\newcommand\mptopcomone{\texttt{MPTOPCOM-1}\xspace}
\newcommand\mts{\texttt{mts}\xspace}
\newcommand\mplrs{\texttt{mplrs}\xspace}
\newcommand\soplex{\texttt{soplex}\xspace}
\newcommand\openmpi{\texttt{OpenMPI}\xspace}
\newcommand\mpi{\texttt{MPI}\xspace}
\newcommand\gfan{\texttt{Gfan}\xspace}
\newcommand\cddlib{\texttt{cddlib}\xspace}
\newcommand\polydb{\texttt{PolyDB}\xspace}
\newcommand\oscar{\texttt{OSCAR}\xspace}

\usepackage{xcolor}
\definecolor{green}{rgb}{0.1,0.59,0.1}
\definecolor{yellow}{rgb}{0.8,0.67,0}
\definecolor{red}{rgb}{0.89,0.1,0.1}
\definecolor{blue}{rgb}{0.1,0.1,0.89}

\usenavigationsymbolstemplate{}

\usepackage{booktabs}
% For software citations
\newcommand{\polymake}{\texttt{po\-ly\-ma\-ke}\xspace}
\newcommand{\polymakejl}{\texttt{Po\-ly\-ma\-ke.jl}\xspace}
\newcommand{\singular}{\texttt{Sin\-gu\-lar}\xspace}
\newcommand\CPP{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\relsize{-3}{\textbf{+}}}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\relsize{-3}{\textbf{+}}}\xspace}

\usepackage{amsmath}
% Newcommands specifically for this article
\newcommand{\eval}{v}               % evaluation function giving switch table
\newcommand{\graph}{\Gamma}         % reverse search graph
\newcommand{\group}{G}              % group acting on point config
\newcommand{\groupElem}{g}          % element of group
\newcommand{\jbound}{\psi}          % bound on the number of elements of set J
\newcommand{\switchTableSize}{\mu}  % index of last non-trivial row in switch table

\newcommand{\pc}{\mathcal P\mathcal C}
\newcommand{\ZZ}{\mathbb Z}
\renewcommand{\AA}{\mathcal A}
\newcommand{\QQ}{\mathbb Q}
\newcommand{\OO}{\mathcal O}
\newcommand{\CC}{\mathbb C}
\newcommand{\PP}{\mathbb P}
\newcommand{\RR}{\mathbb R}
\newcommand{\scalp}[1]{\langle #1 \rangle}
\newcommand{\wt}{\omega}
\newcommand{\cT}{\mathcal T}
\renewcommand{\O}{\mathcal O}
\newcommand{\adm}{\mathcal A(\D, M)}
\newcommand{\blue}[1]{{\usebeamercolor[fg]{palette primary}#1}}

\DeclareMathOperator{\CaDiv}{CaDiv}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\below}{defect}
\DeclareMathOperator{\vertex}{vertex}
\DeclareMathOperator{\Cox}{Cox}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\cone}{cone}
\DeclareMathOperator{\Ext}{Ext}
\DeclareMathOperator{\Tor}{Tor}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Quot}{Quot}
\DeclareMathOperator{\Spec}{Spec}
\DeclareMathOperator{\Sets}{Sets}
\DeclareMathOperator{\relint}{relint}
\DeclareMathOperator{\rk}{rk}
\DeclareMathOperator{\smallestFace}{smallestFace}
\DeclareMathOperator{\Pic}{Pic}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\vol}{vol}
\DeclareMathOperator{\TV}{TV}
\DeclareMathOperator{\tail}{tail}
\DeclareMathOperator{\rep}{rep}
\DeclareMathOperator{\vspan}{span}
\DeclareMathOperator{\canonical}{can}
\DeclareMathOperator{\gkz}{gkz}

\newcommand{\pmsmall}{\includegraphics[scale=0.03]{pmlogo.png}}
\newcommand{\pmlogo}{\includegraphics[scale=0.09]{pmlogo.png}}
\newcommand{\pmbluesmall}{\includegraphics[scale=0.03]{pmbluelogo.png}}
\newcommand{\Disjoint}{\mathop{\coprod}}
\newcommand{\Discriminant}{\mathcal{D}}

\theoremstyle{definition}
\newtheorem{remark}{Remark}

\newtheorem{prop}{Proposition}
\newtheorem{defn}{Definition}

\author{Antony Della Vecchia}
\title{Computing Convex Hulls}
%\newtheorem*{example}{Example}
\institute[]{
Technische Universit\"at Berlin
}
\date{
2022-10-12
}


\newcommand{\surj}{\twoheadrightarrow}
\newcommand{\oursetting}[1]{\textcolor{blue}{#1}}
\usepackage{listings}
\begin{document}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Overview}
  \begin{tcolorbox}
    \tableofcontents
  \end{tcolorbox}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Hulls}
  \begin{defn}
    Let $A \subset \mathbb{K}^n$, an \emph{affine combination} of points in $A$
    is a linear combination $\sum_{i=1}^m \lambda_m a_m$ where $\lambda_m \in
    \mathbb{K}$ and $a \in A$ such that $\sum_{i=1}^m \lambda_m = 1$. The
    \emph{affine hull} is the set of all such combinations.
  \end{defn}

  \begin{defn}
    Let $A \subset \mathbb{R}^n$, a \emph{convex combination} of points in $A$
    is an affine combination $\sum_{i=1}^m \lambda_m a_m$ where $\lambda_m \geq
    0$. The  \emph{convex hull} is the set of all such combinations.
  \end{defn}

  \begin{defn}
    Let $A \subset \mathbb{R}^n$, a \emph{postive combination} of points in $A$
    is a linear combination $\sum_{i=1}^m \lambda_m a_m$ where $\lambda_m \geq
    0$. The  \emph{positive hull} is the set of all such combinations.
  \end{defn}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Polytopes}
  \begin{defn}
    A set $P \subset \mathbb{R}^n$ is a \emph{polytope} if it can be described
    as the convex hull of finitely many points. The dimension of $P$ is
    defined to be the dimension of it's affine hull. A \emph{$k$-polytope} is a
    k dimensional polytope. A \emph{$k$-simplex} is the convex hull of $k + 1$
    affine independant points.
  \end{defn}

  \begin{figure}
    \includegraphics[width=.30\textwidth, height=0.4\textheight]{images/square}
    \includegraphics[width=.30\textwidth, height=0.4\textheight]{images/simplex}
  \end{figure}

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}[fragile]{Faces}
  \begin{defn}
    Given an n-polytope $P \subset \mathbb{R}^n$, the intersection $P \cap H$
    with a supporting hyperplane $H$ is called a \emph{proper face}. A face of
    dimension $k$ is called a $k$ face, a 0-face is a vertex, 1-face an edge,
    n-2 face a ridge and an n-1 face a facet.
  \end{defn}
  \begin{remark}
    Proper faces are also polytopes with respect to their affine hull.
  \end{remark}
  \begin{theorem}
    The boundary of a full dimesional polytope is the union of all it's
    proper faces.
  \end{theorem}

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Half-spaces}
  \begin{defn}
    Given an affine hyperplane $H \subset \mathbb{R}^n$ given in homegeneous
    coordinates as $[a_0, \dots, a_n]$, define the \emph{positive halfspace}
    $H^+$ as $\{x \in \mathbb{R}^n \mid a_0 + a_1x_1 + \dots + a_nx_n \geq 0 \}$.
  \end{defn}

  \begin{remark}
    For each facet $f$ of a polytope $P$, there exists a positive halfspace $H^+$
    such that $f = P \cap H$ and $ P \subset H^+$
  \end{remark}

  \begin{center}
    \includegraphics[width=.30\textwidth, height=0.4\textheight]{images/half-space}
  \end{center}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Polytope Descriptions}
  \begin{theorem}
    Let $H_i$ be the supporting hyperplanes for the facets of a polytope $P$.
    then $P = \cap_i^m H_i^+$
  \end{theorem}
  \begin{theorem}
    Every polytope is the convex hull of it's vertices
  \end{theorem}
  \begin{remark}
    We call $P =  \text{conv}(v_1, \dots, v_m)$ a $\mathcal{V}$-description, and
    we call $P =  \cap_{i=1}^kH_i^+$ an $\mathcal{H}$-description. An algorithm
    that finds a $V$-description from an $\mathcal{H}$-description is referred to as a convex
    hull computation. We call the pair ${V, \mathcal{H} }$ a double description of $P$.
  \end{remark}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}[fragile]{Polarity and Duality}
  \begin{defn}
    Given a set $X \subset \mathbb{R}^n$ define the polar set as
    $X^o = \{y \in \mathbb{R}^n \mid x_1y_1 + \dots x_ny_n \leq 1\}$
  \end{defn}
  \begin{theorem}
    If $P \subset \mathbb{R}^n$ is an $n$-polytope with $0 \in \text{int}P$ then
    $P^o$ is also an $n$-polytope, and for $V$ the vertex set of $P$ we have
    \begin{center}
      $P^o = \bigcap_{v \in V} \set{y \in \R^n \mid \langle v, y \rangle \leq 1} = \bigcap_{v \in V} [1: -v_0: \dots : -v_n]^+$
    \end{center}
  \end{theorem}
  \begin{center}
    \includegraphics[width=.30\textwidth, height=0.4\textheight]{images/polar}
  \end{center}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Polarity and Duality}
  \begin{theorem}
    Let $P \subset \R^n$ be an $n$ polytope with $0 \in \text{int}P$ then
    \begin{itemize}
    \item $(P^o)^o = P$
    \item For any point $p$ on the boundary of $P$, $H = \set{x \in \R^n
      \mid \langle p, x \rangle = 1}$ is a supporting hyperplane of $P^o$
    \end{itemize}
  \end{theorem}
  \begin{remark}
    If $0 \in \text{int} P$, where $P = \bigcap_{i=1}^m H_i^+$, then we can write
    $H_i^+ = [1:-h_1^{(i)}: \dots: -h_n^{(i)}]$, then $P^o = \text{conv}(h_1, \dots, h_n)$.
    So, finding a half-space description of $P^o$ will give us the vertices of $P$.
    So we can reduce the problem of finding a $V$-description from an $\mathcal{H}$-description
    to a convex hull computation. 
  \end{remark}
  
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Polyhedra}
  \begin{defn}
    $P \subset \R^n$ is called a \emph{polyhedron} if it can be described by a finite
    intersection of closed affine half-spaces. A polyhedron that doesn't contain an affine
    line is called \emph{pointed}.
  \end{defn}

  \begin{theorem}
    Every pointed polyhedron is projectively equivalent to a polytope. 
  \end{theorem}

  add matrices for the transformations
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Description of Polyhedra}
  \begin{defn}
    Given two sets $X, Y \subset \R^n$, the \emph{Minkowski Sum}  is defined as
    $X + Y = \set{x + y \mid x \in X, y \in Y}
  \end{defn}

  \begin{theorem}
    Every polyhedron $P$ can be expressed as the Minkowski sum
    \begin{center}
      $P$ = conv$V$ + pos$R$
    \end{center}
    where $V$, $R$ are finite.
  \end{theorem}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{}
  blah
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Algorithms}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{A Trivial Algorithm}
  
  \begin{algorithm}[H]
    \textbf{Input:} Finite point set $V \subset \R^n$ with dimension of $\text{aff}V = n$\\
    \textbf{Output:} Finite set of half-spaces $H_i^+$ such that $\text{conv}(V) =
    \cap_{i=1}^m H_i^+$
    \begin{algorithmic}[1]
      \STATE $\mathcal{H} \leftarrow \emptyset$
      \FOR{each $n$ element subset $W \subset V$ with dimension aff$W = n-1$ }
      \STATE $H \leftarrow \text{aff} W$
      \IF{$V \subset H^+$}
      \STATE $\mathcal{H} \leftarrow \mathcal{H} \cup H^+$
      \ELSE $\mathcal{H} \leftarrow \mathcal{H} \cup H^-$
      \ENDIF
      \ENDFOR
      \RETURN $\mathcal{H}$
    \end{algorithmic}
  \end{algorithm}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{A Worst Case Example}
  \begin{defn}
    The \emph{moment curve} $\mu_n \to \mathbb{R}^n$ is defined as
    $\tau \to (\tau, \dots, \tau^n)$. A polytope is called \emph{cyclic}
    if it is the convex hull of points on the moment curve.
  \end{defn}
    
  \begin{remark}
    Notice that since any $n + 1$ vertices lie in a distinct supporting
    hyperplane, each facet is an $n$-simplex. Hence we have many facets $\Theta(m^{\lfloor n / 2 \rfloor })$, and cannot expect an algorithm that is polynomial in $n$ and $m$.
  
  \end{remark}

  \begin{center}
    \includegraphics[width=.30\textwidth, height=0.4\textheight]{images/cyclic}
  \end{center}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{A Partitioning Lemma}
  \begin{lemma}
    Let $P = \text{conv}V$, and let $P' = P \cap H^+$, where $H$ is a hyperplane. \\
    Let $V_0, V_+, V_-$ be the partition of a point set $V$, defined by
    \begin{center}
      $V_0 = V \cap H, V_+ = V \cap H^+ \setminus H, V_- = V \cap H^- \setminus H$
    \end{center}
    where $H$ is a hyperplane. Then we have
    \begin{center}
      $P' \cap H^+ =
      \text{conv}(V_0 \cup V_+ \cup \set{[v, w] \cap H \mid v \in V_+ , w \in V_-})$
      \end{center}
  \end{lemma}
    \begin{center}
    \includegraphics[width=.50\textwidth, height=0.4\textheight]{images/lemma}
  \end{center}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{A Basic Algorithm }
  \begin{algorithm}[H]
    \textbf{Input:} A set of affine half-spaces $\mathcal{H} = \set{H_1^+, \dots, H_m^+}$
    in $\R^n$ such that $P = \cap_{i=1}^m H_i^+$ is bounded and full dimensional
    and $P_{n+1} = \cap_{i=1}^{n+1}H_i^+$ is an $n$-simplex\\
    \textbf{Output:} Point set $V$ such that $\text{conv}V = P$
    \begin{algorithmic}[1]
      \STATE $V_{n+1} \leftarrow$ set of vertices of $P_{n+1}$
      \FOR{$k=n+2$ to $m$}
      \STATE Construct $V_k = P_k = P_{k-1} \cap H_k^+$ as in the lemma
      \ENDFOR
    \end{algorithmic}
  \end{algorithm}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{}
  \begin{itemize}
  \item The basic algorithm is an improvement on the trivial one.
  \item The basic algorithm uses points that aren't vertices.
  \item At each iteration we may have that the points increase quadratically.
  \item Improvements can be made by noticing that vertices of $P_k$ which are not vertices of $P_{k-1}$ are generated by edges of $P_{k-1}$ that intersect the hyperplane $H_k$
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Edge Detecting Lemma }
  \begin{defn}
    Let $W \subset V$ be a point set and define $\mathcal{H}(W) = \set{H \mid H = \partial H^+ \text{ for } H \in \mathcal{H^+} \text{ and } W \subset H}$. For simplicity we denote $H(\set{v, w})$ as $H(v, w)$
  \end{defn}
  \begin{lemma}
    Let $(V, \mathcal{H})$ be a double description of an $n$-polytope $P$. Given two distinct points $v, w \in V$ the set aff$\set{v, w} \cap P$ is an edge of $P$ if and only if
    \begin{center}
      $\cap \mathcal{H}(v, w) = \text{aff}\set{v, w}$.
    \end{center}

    
    When $v, w$ are vertices then
    \begin{center}
      conv$\set{v, w} = P \cap (\cap \mathcal{H}(v, w))$
    \end{center}
  \end{lemma}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{}
  blah
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}[fragile]{An Improved Algorithm}
  \textbf{Input:} A matrix $\mathcal{H} \in \R^{k\times(n+1)}$ with row vectors $h^{(1)}, \dots , h^{(k)}$ such that $Q = \set{x \in \R^{n+1} \mid \mathcal{H}x \geq 0}$ and $Q_{n+1} = \set{x \in \R^{n+1} \mid h^{(1)}x \geq 0, \dots, h^{(n)}x \geq 0 }$ is a simplicial cone\\
    \textbf{Output:} A set $W$ of vectors such that pos$W = Q$
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Algorithm Continued}
    \begin{algorithmic}[1]
      \STATE Find $W_{n+1} \in \R^{n+1 \times n+1}$ such that it's columns generate $Q$
      \FOR{$i=n+2$ to $k$}
      \STATE Create $W_{i-1}^+$ from the columns of $W_{i-1}$ that lie on the positive side of $h^{(i)}$ and create $W_{i-1}^_$ from the columns that lie on negative side.

      \IF{$W_{i-1}^- = \emptyset$}
      \STATE $W_i \leftarrow W_{i-1}$

      \ELSE
      \STATE $X \leftarrow \emptyset$

      \FOR{Each pair (w, w') of columns of $W_{i-1}^+$ and $W_{i-1}^-$}
      \IF{rank \mathcal{H}_{i-1}(w, w') = n-1}
      \STATE choose $x$ as a generator of the kernel of the matrix $\mathcal{H'}_{i-1}(w, w')$ that consists of the rows of $\mathcal{H}_{i-1}(w, w')$ and $h^{(i)}$.

      \STATE $X \leftarrow X \cup \set{x}$
      \ENDIF
      \STATE Let $W_i$ be the matrix consisting of the columns of $W_{i-1}$ without the columns of $W_{i-1}^-$ and augmented by the column vectors from $X$.
      
      \ENDIF
      
      \ENDFOR
      \RETURN W_k
    \end{algorithmic}
  \end{algorithm}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Remarks on Implementations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{}
  blah
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{References}
  \footnotesize{
    \begin{thebibliography}{99} % Beamer does not support BibTeX so references must be inserted manually as below
    \bibitem[Joswig, Thorsten, 2013]{p1} Michael Joswig, Thorsten Theobald, (2013)
      \newblock Polyhedral and algebraic methods in computational geometry
      \newblock London: Springer

    \bibitem[chulls 2017]{p1} Assarf, Benjamin and Gawrilow, Ewgenij and Herr, Katrin and Joswig, Michael and Lorenz, Benjamin and Paffenholz, Andreas and Rehn, Thomas, (2017)
      \newblock Computing convex hulls and counting integer points with \texttt{polymake}
      \newblock Mathematical Programming Computation 9(1), 1--38 



  \end{thebibliography}
  }
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
